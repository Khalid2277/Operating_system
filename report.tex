\documentclass[11pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{enumitem}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=C,
    numbers=left,
    numberstyle=\tiny\color{gray},
    commentstyle=\color{green!50!black},
    keywordstyle=\color{blue},
    backgroundcolor=\color{gray!5}
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Producer-Consumer Application}
\lhead{Operating Systems Project}
\rfoot{Page \thepage}

\title{\textbf{Multithreaded Producer-Consumer Application\\with Priority Handling and Performance Metrics}}
\author{
    Khalid Alfahim - b00100122 \\
    Ahmad Mustafawi - b00094873\\
    \\
    \textit{Operating Systems - CMP 310} \\
    \textit{American University of Sharjah}
}
\date{November 16, 2025}

\begin{document}

\maketitle

\section{Design Decisions}

\subsection{Synchronization Strategy}

Our implementation uses semaphores and mutexes to ensure thread-safe access to the shared buffer and prevent race conditions.

\textbf{Semaphores for Buffer Management:} We use three semaphores for synchronization. The \texttt{mutex} semaphore (initialized to 1) provides mutual exclusion for critical sections. The \texttt{empty} semaphore (initialized to buffer size) tracks available slots and blocks producers when the buffer is full. The \texttt{full} semaphore (initialized to 0) tracks occupied slots and blocks consumers when the buffer is empty. This approach eliminates busy-waiting, as threads block efficiently on semaphore operations.

\textbf{Critical Section Protection:} The \texttt{mutex} semaphore protects the buffer during insertion and removal operations, ensuring only one thread modifies the buffer at a time. A separate \texttt{stats\_lock} mutex protects shared statistics counters to prevent race conditions during metric updates.

\textbf{Rationale:} This synchronization strategy prevents overflow/underflow conditions, data corruption, and race conditions without busy-waiting or inefficient polling mechanisms.

\subsection{Circular Buffer Implementation}

The buffer uses a dynamically allocated array with \texttt{in} and \texttt{out} indices that wrap around using modulo arithmetic: \texttt{(index + 1) \% buffer\_size}. The \texttt{in} index points to where the next item will be inserted (producer), and \texttt{out} points to where the next item will be removed (consumer).

\textbf{Rationale:} Circular buffers maximize memory efficiency by reusing array slots. The modulo operation handles wrapping automatically, enabling continuous operation without memory reallocation.

\subsection{Priority Handling (Bonus Feature)}

Each buffer item contains a priority field (1=urgent, 0=normal, -1=poison pill). Priority handling is implemented on the consumer side in the \texttt{remove\_item()} function. The function first counts items in the buffer, then performs a linear scan to find the highest-priority item. Once found, that item is extracted and saved. If the selected item is not at the front position, items between \texttt{out} and the selected position are shifted forward to fill the gap. This ensures urgent items are always consumed before normal items, with poison pills consumed last.

\textbf{Rationale:} Implementing priority on the consumer side with defensive counting and explicit item extraction ensures correctness. The algorithm guarantees that urgent items (priority = 1) are consumed first, normal items (priority = 0) second, and poison pills (priority = -1) last, preventing premature consumer termination. Approximately 25\% of items are marked urgent via random probability checking.

\subsection{Poison Pill Termination}

After all producer threads complete and are joined, the main thread inserts one poison pill (special value $-1$) per consumer into the buffer. Poison pills are assigned priority $-1$, ensuring they are consumed only after all real items. Upon receiving a poison pill, each consumer terminates its loop gracefully.

\textbf{Rationale:} This technique guarantees that consumers don't exit prematurely while producers are still active, and ensures all real items are consumed before termination. The priority-based approach prevents poison pills from being consumed early, which would cause item loss.

\subsection{Performance Metrics (Bonus Feature)}

Each item records an enqueue timestamp using \texttt{gettimeofday()} when produced. Consumers record dequeue timestamps upon removal, calculating latency as the difference. Average latency and throughput (items/second) are computed and displayed after all threads complete.

\textbf{Rationale:} These metrics provide quantitative insight into system performance, demonstrating how buffer size affects contention, latency, and throughput. Microsecond-precision timestamps enable meaningful measurements even for fast operations.

\section{Challenges and Solutions}

\subsection{Challenge 1: Priority Queue in Circular Buffer}

\textbf{Problem:} Implementing priority handling in a circular buffer is challenging because standard circular buffers follow strict FIFO ordering. We needed to maintain FIFO within each priority level while allowing urgent items to bypass normal items.

\textbf{Solution:} We implemented priority handling on the consumer side with a defensive linear scan. The algorithm first counts items in the buffer for safe iteration (preventing infinite loops), then scans all items to find the highest priority. After extracting the selected item, it shifts intervening items forward to maintain buffer integrity.

\begin{lstlisting}[caption={Priority Removal Logic}, captionpos=b]
// Count items for safe iteration
int count = 0;
int temp_pos = out;
while (temp_pos != in && count < buffer_size) {
    count++;
    temp_pos = (temp_pos + 1) % buffer_size;
}

// Scan for highest priority item
for (int i = 0; i < count; i++) {
    if (buffer[current_pos].priority > best_priority) {
        best_priority = buffer[current_pos].priority;
        best_pos = current_pos;
    }
    current_pos = (current_pos + 1) % buffer_size;
}
\end{lstlisting}

\subsection{Challenge 2: Premature Consumer Termination}

\textbf{Problem:} Initial implementation assigned poison pills priority = 1 (urgent), causing them to be consumed before remaining normal items. This resulted in consumers terminating early, leaving items unconsumed.

\textbf{Solution:} Changed poison pill priority to $-1$, ensuring they are consumed only after all real items (urgent and normal) have been processed. This guarantees correct termination without item loss.

\subsection{Challenge 3: Race Conditions in Statistics}

\textbf{Problem:} Multiple threads concurrently updating shared counters (\texttt{total\_produced}, \texttt{total\_consumed}, \texttt{total\_latency}) could cause race conditions and incorrect counts.

\textbf{Solution:} We introduced a separate \texttt{stats\_lock} mutex specifically for protecting statistics updates. This prevents contention with the main buffer semaphore and allows statistics updates to occur independently.

\subsection{Challenge 4: Thread-Safe Random Number Generation}

\textbf{Problem:} The standard \texttt{rand()} function uses shared state and is not thread-safe, potentially causing race conditions when called from multiple producer threads.

\textbf{Solution:} We use \texttt{rand\_r()} with per-thread seeds: \texttt{unsigned int seed = time(NULL) + producer\_id}. This allows each thread to maintain its own random state without shared state or locking overhead.

\subsection{Challenge 5: Memory Management}

\textbf{Problem:} Dynamic memory allocation for thread IDs, buffers, and latency arrays requires careful management to avoid memory leaks.

\textbf{Solution:} We allocate thread IDs in main, pass them to thread functions, and free them immediately after use inside each thread. Buffers and arrays are allocated during initialization and freed in a dedicated cleanup function called at program termination.

\section{Performance Analysis}

We tested the application with varying buffer sizes to observe performance characteristics:

\begin{table}[h]
\centering
\caption{Performance Metrics for Different Buffer Sizes}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Configuration} & \textbf{Buffer Size} & \textbf{Avg Latency (sec)} & \textbf{Throughput (items/sec)} \\ \midrule
3P, 2C & 10 & $\sim$0.000150 & $\sim$24,000 \\
8P, 8C & 32 & $\sim$0.000020 & $\sim$50,000 \\ \bottomrule
\end{tabular}
\end{table}

\textbf{Interpretation:} Small buffers create higher contention, causing more frequent blocking. Larger buffers reduce contention significantly, allowing more concurrent operations, resulting in higher throughput and lower latency. Priority handling adds minimal overhead due to efficient linear scanning within the mutex-protected critical section.

\section{Testing and Verification}

The application was rigorously tested with various configurations:
\begin{itemize}[leftmargin=*, itemsep=0pt]
    \item \textbf{Correctness:} Verified that total items produced equals total items consumed for all test cases (100\% success rate over 20+ test runs)
    \item \textbf{Priority Handling:} Confirmed through output logs that urgent items are consistently consumed before later-enqueued normal items, and poison pills are consumed last
    \item \textbf{Concurrency:} Tested with up to 20 threads (10 producers, 10 consumers) without deadlocks or data corruption
    \item \textbf{Edge Cases:} Single thread (1P, 1C), minimal buffer (size 1), and large configurations all operate correctly
    \item \textbf{Memory Safety:} No memory leaks detected in validation testing
\end{itemize}

\section{Individual Contributions}

\begin{itemize}[leftmargin=*, itemsep=2pt]
    \item \textbf{[Khalid Alfahim]}: Implemented circular buffer structure and core semaphore/mutex synchronization mechanisms (30\%)
    \item \textbf{[Khalid Alfahim - Ahmad Mustafawi]}: Developed producer and consumer thread functions, implemented poison pill termination technique (30\%)
    \item \textbf{[Ahmad Mustafawi]}: Implemented priority handling bonus feature with defensive scanning algorithm (20\%)
    \item \textbf{[Khalid Alfahim - Ahmad Mustafawi]}: Added performance metrics tracking, conducted testing, and wrote comprehensive documentation (20\%)
\end{itemize}

\section{Conclusion}

This project successfully demonstrates multithreaded programming with proper synchronization using POSIX semaphores and mutexes. The implementation correctly handles concurrent access to a shared circular buffer, provides graceful termination via the poison pill technique, and includes both bonus features (priority handling and performance metrics) while maintaining code correctness and reliability.

Key achievements include:
\begin{itemize}[leftmargin=*, itemsep=0pt]
    \item Correct circular buffer implementation with \texttt{in}/\texttt{out} indexing
    \item Proper synchronization using semaphores (\texttt{mutex}, \texttt{empty}, \texttt{full})
    \item No busy-waiting, deadlocks, or race conditions
    \item Priority queue functionality with defensive iteration and safe shifting
    \item Comprehensive performance metrics (latency and throughput tracking)
    \item Robust error handling and memory management
    \item 100\% reliability: All real items consumed before poison pill termination
\end{itemize}

\end{document}

